{"version":3,"file":"array.js","sources":["../../src/-private/array.ts"],"sourcesContent":["/* eslint-disable @typescript-eslint/no-explicit-any */\n// Unfortunately, TypeScript's ability to do inference *or* type-checking in a\n// `Proxy`'s body is very limited, so we have to use a number of casts `as any`\n// to make the internal accesses work. The type safety of these is guaranteed at\n// the *call site* instead of within the body: you cannot do `Array.blah` in TS,\n// and it will blow up in JS in exactly the same way, so it is safe to assume\n// that properties within the getter have the correct type in TS.\n\nimport {\n  type TrackedStorage,\n  createStorage,\n  getValue,\n  setValue,\n} from 'ember-tracked-storage-polyfill';\n\nconst ARRAY_GETTER_METHODS = new Set<string | symbol | number>([\n  Symbol.iterator,\n  'concat',\n  'entries',\n  'every',\n  'filter',\n  'find',\n  'findIndex',\n  'flat',\n  'flatMap',\n  'forEach',\n  'includes',\n  'indexOf',\n  'join',\n  'keys',\n  'lastIndexOf',\n  'map',\n  'reduce',\n  'reduceRight',\n  'slice',\n  'some',\n  'values',\n]);\n\n// For these methods, `Array` itself immediately gets the `.length` to return\n// after invoking them.\nconst ARRAY_WRITE_THEN_READ_METHODS = new Set<string | symbol>([\n  'fill',\n  'push',\n  'unshift',\n]);\n\nfunction convertToInt(prop: number | string | symbol): number | null {\n  if (typeof prop === 'symbol') return null;\n\n  const num = Number(prop);\n\n  if (isNaN(num)) return null;\n\n  return num % 1 === 0 ? num : null;\n}\n\n// eslint-disable-next-line @typescript-eslint/no-unsafe-declaration-merging\nclass TrackedArray<T = unknown> {\n  /**\n   * Creates an array from an iterable object.\n   * @param iterable An iterable object to convert to an array.\n   */\n  static from<T>(iterable: Iterable<T> | ArrayLike<T>): TrackedArray<T>;\n\n  /**\n   * Creates an array from an iterable object.\n   * @param iterable An iterable object to convert to an array.\n   * @param mapfn A mapping function to call on every element of the array.\n   * @param thisArg Value of 'this' used to invoke the mapfn.\n   */\n  static from<T, U>(\n    iterable: Iterable<T> | ArrayLike<T>,\n    mapfn: (v: T, k: number) => U,\n    thisArg?: unknown,\n  ): TrackedArray<U>;\n\n  static from<T, U>(\n    iterable: Iterable<T> | ArrayLike<T>,\n    mapfn?: (v: T, k: number) => U,\n    thisArg?: unknown,\n  ): TrackedArray<T> | TrackedArray<U> {\n    return mapfn\n      ? new TrackedArray(Array.from(iterable, mapfn, thisArg))\n      : new TrackedArray(Array.from(iterable));\n  }\n\n  static of<T>(...arr: T[]): TrackedArray<T> {\n    return new TrackedArray(arr);\n  }\n\n  constructor(arr: T[] = []) {\n    const clone = arr.slice();\n    // eslint-disable-next-line @typescript-eslint/no-this-alias\n    const self = this;\n\n    const boundFns = new Map<string | symbol, (...args: any[]) => any>();\n\n    /**\n      Flag to track whether we have *just* intercepted a call to `.push()` or\n      `.unshift()`, since in those cases (and only those cases!) the `Array`\n      itself checks `.length` to return from the function call.\n     */\n    let nativelyAccessingLengthFromPushOrUnshift = false;\n\n    return new Proxy(clone, {\n      get(target, prop /*, _receiver */) {\n        const index = convertToInt(prop);\n\n        if (index !== null) {\n          self.#readStorageFor(index);\n          getValue(self.#collection);\n\n          return target[index];\n        }\n\n        if (prop === 'length') {\n          // If we are reading `.length`, it may be a normal user-triggered\n          // read, or it may be a read triggered by Array itself. In the latter\n          // case, it is because we have just done `.push()` or `.unshift()`; in\n          // that case it is safe not to mark this as a *read* operation, since\n          // calling `.push()` or `.unshift()` cannot otherwise be part of a\n          // \"read\" operation safely, and if done during an *existing* read\n          // (e.g. if the user has already checked `.length` *prior* to this),\n          // that will still trigger the mutation-after-consumption assertion.\n          if (nativelyAccessingLengthFromPushOrUnshift) {\n            nativelyAccessingLengthFromPushOrUnshift = false;\n          } else {\n            getValue(self.#collection);\n          }\n\n          return target[prop];\n        }\n\n        // Here, track that we are doing a `.push()` or `.unshift()` by setting\n        // the flag to `true` so that when the `.length` is read by `Array` (see\n        // immediately above), it knows not to dirty the collection.\n        if (ARRAY_WRITE_THEN_READ_METHODS.has(prop)) {\n          nativelyAccessingLengthFromPushOrUnshift = true;\n        }\n\n        if (ARRAY_GETTER_METHODS.has(prop)) {\n          let fn = boundFns.get(prop);\n\n          if (fn === undefined) {\n            fn = (...args) => {\n              getValue(self.#collection);\n              return (target as any)[prop](...args);\n            };\n\n            boundFns.set(prop, fn);\n          }\n\n          return fn;\n        }\n\n        return (target as any)[prop];\n      },\n\n      set(target, prop, value /*, _receiver */) {\n        (target as any)[prop] = value;\n\n        const index = convertToInt(prop);\n\n        if (index !== null) {\n          self.#dirtyStorageFor(index);\n          self.#dirtyCollection();\n        } else if (prop === 'length') {\n          self.#dirtyCollection();\n        }\n\n        return true;\n      },\n\n      getPrototypeOf() {\n        return TrackedArray.prototype;\n      },\n    }) as TrackedArray<T>;\n  }\n\n  #collection = createStorage(null, () => false);\n\n  #storages = new Map<number, TrackedStorage<null>>();\n\n  #readStorageFor(index: number) {\n    let storage = this.#storages.get(index);\n\n    if (storage === undefined) {\n      storage = createStorage(null, () => false);\n      this.#storages.set(index, storage);\n    }\n\n    getValue(storage);\n  }\n\n  #dirtyStorageFor(index: number): void {\n    const storage = this.#storages.get(index);\n\n    if (storage) {\n      setValue(storage, null);\n    }\n  }\n\n  #dirtyCollection() {\n    setValue(this.#collection, null);\n    this.#storages.clear();\n  }\n}\n\n// This rule is correct in the general case, but it doesn't understand\n// declaration merging, which is how we're using the interface here. This says\n// `TrackedArray` acts just like `Array<T>`, but also has the properties\n// declared via the `class` declaration above -- but without the cost of a\n// subclass, which is much slower that the proxied array behavior. That is: a\n// `TrackedArray` *is* an `Array`, just with a proxy in front of accessors and\n// setters, rather than a subclass of an `Array` which would be de-optimized by\n// the browsers.\n//\n// eslint-disable-next-line @typescript-eslint/no-empty-interface\ninterface TrackedArray<T = unknown> extends Array<T> {}\n\nexport default TrackedArray;\n\n// Ensure instanceof works correctly\nObject.setPrototypeOf(TrackedArray.prototype, Array.prototype);\n"],"names":["ARRAY_GETTER_METHODS","Set","Symbol","iterator","ARRAY_WRITE_THEN_READ_METHODS","convertToInt","prop","num","Number","isNaN","TrackedArray","from","iterable","mapfn","thisArg","Array","of","arr","constructor","clone","slice","self","boundFns","Map","nativelyAccessingLengthFromPushOrUnshift","Proxy","get","target","index","getValue","has","fn","undefined","args","set","value","getPrototypeOf","prototype","createStorage","#readStorageFor","storage","#dirtyStorageFor","setValue","#dirtyCollection","clear","Object","setPrototypeOf"],"mappings":"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"}